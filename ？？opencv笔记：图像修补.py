'''
图像修补
目标
本节我们将要学习：
• 使用修补技术去除老照片中小的噪音和划痕
• 使用 OpenCV 中与修补技术相关的函数

在我们每个人的家中可能都会几张退化的老照片，有时候上面不小心在上面弄上了点污渍或者是画了几笔。
你有没有想过要修复这些照片呢？我们可以使用笔刷工具轻易在上面涂抹两下，但这没用，你只是用白色笔画取代了黑色笔画。
此时我们就要求助于图像修补技术了。这种技术的基本想法很简单：
使用坏点周围的像素取代坏点，这样它看起来和周围像素就比较像了。如下图所示（照片来自维基百科）.
为了实现这个目的，科学家们已经提出了好几种算法，OpenCV 提供了其中的两种。
这两种算法都可以通过使用函数 cv2.inpaint() 来实施。

第一个算法是根据 Alexandru_Telea 在 2004 发表的文章实现的。它是基于快速行进算法的。以图像中一个要修补的区域为例。
算法从这个区域的边界开始向区域内部慢慢前进，首先填充区域边界像素。
它要选取待修补像素周围的一个小的邻域，使用这个邻域内的归一化加权和更新待修复的像素值。权重的选择是非常重要的。
对于靠近带修复点的像素点，靠近正常边界像素点和在轮廓上的像素点给予更高的权重。
当一个像素被修复之后，使用快速行进算法（FMM）移动到下一个最近的像素。
FMM 保证了靠近已知（没有退化的）像素点的坏点先被修复，这与手工启发式操作比较类似。
可以通过设置标签参数为 cv2.INPAINT_TELEA 来使用此算法。

第二个算法是根据 Bertalmio,Marcelo,Andrea_L.Bertozzi, 和 Guillermo_Sapiro在 2001 年发表的文章实现的。
这个算法是基于流体动力学并使用了偏微分方程。基本原理是启发式的。
它首先沿着正常区域的边界向退化区域的前进（因为边界是连续的，所以退化区域非边界与正常区域的边界应该也是连续的）。
它通过匹配待修复区域中的梯度向量来延伸等光强线（isophotes，由灰度值相等的点练成的线）。
为了实现这个目的，作者是用来流体动力学中的一些方法.完成这一步之后，通过填充颜色来使这个区域内的灰度值变化最小。
可以通过设置标签参数为 cv2.INPAINT_NS 来使用此算法。

我们要创建一个与输入图像大小相等的掩模图像，将待修复区域的像素设置为 255（其他地方为 0）。
所有的操作都很简单。我要修复的图像中有几个黑色笔画。我是使用画笔工具添加的。
'''

import numpy as np
import cv2

#代码里我读取图片后手动添加噪音和划痕，然后在mask相应的标记
#245,170,255,200
img = cv2.imread('y6.jpg')
img[170:200,245:255]=(0,255,255)
img[310:322,100:220]=(0,255,255)
cv2.imshow('img',img)
mask = np.zeros(img.shape[:2])
mask[170:200,245:255]=255
mask[310:322,100:220]=255
mask=np.uint8(mask)
dst = cv2.inpaint(img,mask,3,cv2.INPAINT_TELEA)
cv2.imshow('dst',dst)
